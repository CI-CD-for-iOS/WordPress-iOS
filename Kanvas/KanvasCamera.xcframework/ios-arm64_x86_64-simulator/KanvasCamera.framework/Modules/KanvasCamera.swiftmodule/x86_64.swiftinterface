// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.3 effective-4.2 (swiftlang-1200.0.29.2 clang-1200.0.30.1)
// swift-module-flags: -target x86_64-apple-ios12.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 4.2 -enforce-exclusivity=checked -O -module-name KanvasCamera
import AVFoundation
import AVFoundation/*.AVMakeRect*/
import Accelerate
import CoreGraphics
import CoreImage
import CoreMedia
import CoreServices
import CoreVideo
import Foundation
import GLKit
@_exported import KanvasCamera
import Metal
import MetalKit
import MobileCoreServices
import OpenGLES
import Photos
import Swift
import UIKit
import VideoToolbox
import os
extension AVAsset {
  public var videoScreenSize: CoreGraphics.CGSize? {
    get
  }
}
public enum KanvasCameraMedia {
  case image(Foundation.URL, KanvasCamera.MediaInfo, CoreGraphics.CGSize)
  case video(Foundation.URL, KanvasCamera.MediaInfo, CoreGraphics.CGSize)
  case frames(Foundation.URL, KanvasCamera.MediaInfo, CoreGraphics.CGSize)
  public var info: KanvasCamera.MediaInfo {
    get
  }
}
public enum KanvasExportAction {
  case previewConfirm
  case confirm
  case post
  case save
  case postOptions
  public static func == (a: KanvasCamera.KanvasExportAction, b: KanvasCamera.KanvasExportAction) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public protocol CameraControllerDelegate : AnyObject {
  func didCreateMedia(_ cameraController: KanvasCamera.CameraController, media: [(KanvasCamera.KanvasCameraMedia?, Swift.Error?)], exportAction: KanvasCamera.KanvasExportAction)
  func dismissButtonPressed(_ cameraController: KanvasCamera.CameraController)
  func tagButtonPressed()
  func editorDismissed()
  func didDismissWelcomeTooltip()
  func cameraShouldShowWelcomeTooltip() -> Swift.Bool
  func didDismissColorSelectorTooltip()
  func editorShouldShowColorSelectorTooltip() -> Swift.Bool
  func didEndStrokeSelectorAnimation()
  func editorShouldShowStrokeSelectorAnimation() -> Swift.Bool
  func didBeginDragInteraction()
  func didEndDragInteraction()
  func openAppSettings(completion: ((Swift.Bool) -> ())?)
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class CameraController : UIKit.UIViewController, KanvasCamera.EditorControllerDelegate {
  weak public var delegate: KanvasCamera.CameraControllerDelegate?
  convenience public init(settings: KanvasCamera.CameraSettings, stickerProvider: KanvasCamera.StickerProvider?, analyticsProvider: KanvasCamera.KanvasCameraAnalyticsProvider?, quickBlogSelectorCoordinator: KanvasCamera.KanvasQuickBlogSelectorCoordinating?)
  @available(*, unavailable, message: "use init(settings:) instead")
  @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @available(*, unavailable, message: "use init(settings:) instead")
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @objc override dynamic public var preferredStatusBarStyle: UIKit.UIStatusBarStyle {
    @objc get
  }
  @objc override dynamic public var preferredStatusBarUpdateAnimation: UIKit.UIStatusBarAnimation {
    @objc get
  }
  @objc override dynamic public var supportedInterfaceOrientations: UIKit.UIInterfaceOrientationMask {
    @objc get
  }
  public func requestAccess(_ completion: ((Swift.Bool) -> ())?)
  public func logOpen()
  public func logDismiss()
  @objc override dynamic public func loadView()
  @objc override dynamic public func viewDidLoad()
  @objc override dynamic public func viewDidAppear(_ animated: Swift.Bool)
  public func addButtonPressed()
  public func didFinishExportingVideo(url: Foundation.URL?, info: KanvasCamera.MediaInfo?, action: KanvasCamera.KanvasExportAction, mediaChanged: Swift.Bool)
  public func didFinishExportingImage(image: UIKit.UIImage?, info: KanvasCamera.MediaInfo?, action: KanvasCamera.KanvasExportAction, mediaChanged: Swift.Bool)
  public func didFinishExportingFrames(url: Foundation.URL?, size: CoreGraphics.CGSize?, info: KanvasCamera.MediaInfo?, action: KanvasCamera.KanvasExportAction, mediaChanged: Swift.Bool)
  public func dismissButtonPressed()
  public func tagButtonPressed()
  public func editorShouldShowColorSelectorTooltip() -> Swift.Bool
  public func didDismissColorSelectorTooltip()
  public func editorShouldShowStrokeSelectorAnimation() -> Swift.Bool
  public func didEndStrokeSelectorAnimation()
  public func cleanup()
  public func resetState()
  public func onPostOptionsDismissed()
  @objc deinit
}
public enum ImagePreviewMode {
  case on
  case off
  public static func == (a: KanvasCamera.ImagePreviewMode, b: KanvasCamera.ImagePreviewMode) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
@objc public enum CameraMode : Swift.Int {
  case stopMotion = 0
  case photo
  case loop
  case normal
  case stitch
  case gif
  @objc public enum Group : Swift.Int {
    case video = 0
    case photo
    case gif
    public typealias RawValue = Swift.Int
    public init?(rawValue: Swift.Int)
    public var rawValue: Swift.Int {
      get
    }
  }
  @objc public enum Quantity : Swift.Int {
    case single = 0
    case multiple
    public typealias RawValue = Swift.Int
    public init?(rawValue: Swift.Int)
    public var rawValue: Swift.Int {
      get
    }
  }
  public var group: KanvasCamera.CameraMode.Group {
    get
  }
  public var quantity: KanvasCamera.CameraMode.Quantity {
    get
  }
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
public struct CameraFeatures {
  public var ghostFrame: Swift.Bool
  public var openGLPreview: Swift.Bool
  public var openGLCapture: Swift.Bool
  public var metalPreview: Swift.Bool
  public var cameraFilters: Swift.Bool
  public var metalFilters: Swift.Bool
  public var experimentalCameraFilters: Swift.Bool
  public var editor: Swift.Bool
  public var editorGIFMaker: Swift.Bool
  public var editorFilters: Swift.Bool
  public var editorText: Swift.Bool
  public var editorMedia: Swift.Bool
  public var editorDrawing: Swift.Bool
  public var mediaPicking: Swift.Bool
  public var editorPosting: Swift.Bool
  public var editorPublishing: Swift.Bool
  public var editorPostOptions: Swift.Bool
  public var editorSaving: Swift.Bool
  public var newCameraModes: Swift.Bool
  public var gifs: Swift.Bool
  public var multipleExports: Swift.Bool
}
@_inheritsConvenienceInitializers @objc final public class CameraSettings : ObjectiveC.NSObject {
  final public var enabledModes: Swift.Set<KanvasCamera.CameraMode> {
    get
    set
  }
  final public var defaultMode: KanvasCamera.CameraMode? {
    get
    set
  }
  final public var defaultCameraPositionOption: AVFoundation.AVCaptureDevice.Position {
    get
    set
  }
  final public var preferredFlashOption: AVFoundation.AVCaptureDevice.FlashMode
  final public var imagePreviewOption: KanvasCamera.ImagePreviewMode
  final public var cameraSupportsLandscape: Swift.Bool
  final public var exportStopMotionPhotoAsVideo: Swift.Bool
  final public var features: KanvasCamera.CameraFeatures
  final public var topButtonsSwapped: Swift.Bool
  final public var crossIconInEditor: Swift.Bool
  final public var showTagButtonInEditor: Swift.Bool
  final public func editorShouldStartGIFMaker(mode: KanvasCamera.CameraMode?) -> Swift.Bool
  final public func setEditorShouldStartGIFMaker(_ newValue: Swift.Bool)
  final public var gifCameraShouldStartGIFMaker: Swift.Bool
  @objc override dynamic public init()
  @objc deinit
}
public struct KanvasDevice {
  public static let isRunningInSimulator: Swift.Bool
  public static let belongsToIPhoneXGroup: Swift.Bool
}
public protocol EasyTipViewDelegate : AnyObject {
  func easyTipViewDidDismiss(_ tipView: KanvasCamera.EasyTipView)
}
extension EasyTipView {
  public class func show(animated: Swift.Bool = true, forItem item: UIKit.UIBarItem, withinSuperview superview: UIKit.UIView? = nil, text: Swift.String, preferences: KanvasCamera.EasyTipView.Preferences = EasyTipView.globalPreferences, delegate: KanvasCamera.EasyTipViewDelegate? = nil)
  public class func show(animated: Swift.Bool = true, forView view: UIKit.UIView, withinSuperview superview: UIKit.UIView? = nil, text: Swift.String, preferences: KanvasCamera.EasyTipView.Preferences = EasyTipView.globalPreferences, delegate: KanvasCamera.EasyTipViewDelegate? = nil)
  public func show(animated: Swift.Bool = true, forItem item: UIKit.UIBarItem, withinSuperView superview: UIKit.UIView? = nil)
  public func show(animated: Swift.Bool = true, forView view: UIKit.UIView, withinSuperview superview: UIKit.UIView? = nil)
  public func dismiss(withCompletion completion: (() -> ())? = nil)
  public func isVisible() -> Swift.Bool
  public func itemIsInSuperView(forItem item: UIKit.UIBarItem, withinSuperView superview: UIKit.UIView) -> Swift.Bool
}
extension EasyTipView : UIKit.UIGestureRecognizerDelegate {
  @objc override dynamic open func gestureRecognizerShouldBegin(_ gestureRecognizer: UIKit.UIGestureRecognizer) -> Swift.Bool
}
@objc open class EasyTipView : UIKit.UIView {
  public enum ArrowPosition {
    case any
    case top
    case bottom
    case right
    case left
    public static func == (a: KanvasCamera.EasyTipView.ArrowPosition, b: KanvasCamera.EasyTipView.ArrowPosition) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public struct Preferences {
    public struct Drawing {
      public var cornerRadius: CoreGraphics.CGFloat
      public var arrowHeight: CoreGraphics.CGFloat
      public var arrowWidth: CoreGraphics.CGFloat
      public var foregroundColor: UIKit.UIColor
      public var backgroundColor: UIKit.UIColor
      public var backgroundColorCollection: [UIKit.UIColor]
      public var arrowPosition: KanvasCamera.EasyTipView.ArrowPosition
      public var textAlignment: UIKit.NSTextAlignment
      public var borderWidth: CoreGraphics.CGFloat
      public var borderColor: UIKit.UIColor
      public var font: UIKit.UIFont
    }
    public struct Positioning {
      public var bubbleHInset: CoreGraphics.CGFloat
      public var bubbleVInset: CoreGraphics.CGFloat
      public var textHInset: CoreGraphics.CGFloat
      public var textVInset: CoreGraphics.CGFloat
      public var maxWidth: CoreGraphics.CGFloat
      public var margin: CoreGraphics.CGFloat
    }
    public struct Animating {
      public var dismissTransform: CoreGraphics.CGAffineTransform
      public var showInitialTransform: CoreGraphics.CGAffineTransform
      public var showFinalTransform: CoreGraphics.CGAffineTransform
      public var springDamping: CoreGraphics.CGFloat
      public var springVelocity: CoreGraphics.CGFloat
      public var showInitialAlpha: CoreGraphics.CGFloat
      public var dismissFinalAlpha: CoreGraphics.CGFloat
      public var showDuration: Swift.Double
      public var dismissDuration: Swift.Double
      public var dismissOnTap: Swift.Bool
      public var gradientVelocity: Swift.Double
    }
    public var drawing: KanvasCamera.EasyTipView.Preferences.Drawing
    public var positioning: KanvasCamera.EasyTipView.Preferences.Positioning
    public var animating: KanvasCamera.EasyTipView.Preferences.Animating
    public var hasBorder: Swift.Bool {
      get
    }
    public init()
  }
  @objc override dynamic open var backgroundColor: UIKit.UIColor? {
    @objc get
    @objc set
  }
  @objc override dynamic open var description: Swift.String {
    @objc get
  }
  open var preferences: KanvasCamera.EasyTipView.Preferences {
    get
  }
  final public let text: Swift.String
  public static var globalPreferences: KanvasCamera.EasyTipView.Preferences
  public init(text: Swift.String, preferences: KanvasCamera.EasyTipView.Preferences = EasyTipView.globalPreferences, delegate: KanvasCamera.EasyTipViewDelegate? = nil)
  @objc deinit
  @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc override dynamic open func draw(_ rect: CoreGraphics.CGRect)
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
}
public protocol EditorControllerDelegate : AnyObject {
  func didFinishExportingVideo(url: Foundation.URL?, info: KanvasCamera.MediaInfo?, action: KanvasCamera.KanvasExportAction, mediaChanged: Swift.Bool)
  func didFinishExportingImage(image: UIKit.UIImage?, info: KanvasCamera.MediaInfo?, action: KanvasCamera.KanvasExportAction, mediaChanged: Swift.Bool)
  func didFinishExportingFrames(url: Foundation.URL?, size: CoreGraphics.CGSize?, info: KanvasCamera.MediaInfo?, action: KanvasCamera.KanvasExportAction, mediaChanged: Swift.Bool)
  func dismissButtonPressed()
  func didDismissColorSelectorTooltip()
  func editorShouldShowColorSelectorTooltip() -> Swift.Bool
  func didEndStrokeSelectorAnimation()
  func editorShouldShowStrokeSelectorAnimation() -> Swift.Bool
  func tagButtonPressed()
  func shouldExport() -> Swift.Bool
}
extension EditorControllerDelegate {
  public func shouldExport() -> Swift.Bool
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class EditorViewController : UIKit.UIViewController {
  weak final public var delegate: KanvasCamera.EditorControllerDelegate?
  @available(*, unavailable, message: "use init(settings:, segments:) instead")
  @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @available(*, unavailable, message: "use init(settings:, segments:) instead")
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  public static func createEditor(for image: UIKit.UIImage, settings: KanvasCamera.CameraSettings, stickerProvider: KanvasCamera.StickerProvider, analyticsProvider: KanvasCamera.KanvasCameraAnalyticsProvider) -> KanvasCamera.EditorViewController
  public static func createEditor(for videoURL: Foundation.URL, settings: KanvasCamera.CameraSettings, stickerProvider: KanvasCamera.StickerProvider) -> KanvasCamera.EditorViewController
  public static func createEditor(forGIF url: Foundation.URL, info: KanvasCamera.MediaInfo, settings: KanvasCamera.CameraSettings, stickerProvider: KanvasCamera.StickerProvider, analyticsProvider: KanvasCamera.KanvasCameraAnalyticsProvider, completion: @escaping (KanvasCamera.EditorViewController) -> Swift.Void)
  @objc override final public func viewWillAppear(_ animated: Swift.Bool)
  @objc override final public func viewDidLoad()
  @objc override final public var preferredStatusBarStyle: UIKit.UIStatusBarStyle {
    @objc get
  }
  @objc override final public var supportedInterfaceOrientations: UIKit.UIInterfaceOrientationMask {
    @objc get
  }
  final public func export(_ completion: @escaping (Swift.Result<(UIKit.UIImage?, Foundation.URL?, KanvasCamera.MediaInfo), Swift.Error>) -> Swift.Void)
  @objc deinit
}
@objc public enum FilterType : Swift.Int {
  case passthrough = 0
  case wavePool
  case plasma
  case emInterference
  case rgb
  case lego
  case chroma
  case rave
  case mirrorTwo
  case mirrorFour
  case lightLeaks
  case film
  case grayscale
  case manga
  case toon
  case off
  public func key() -> Swift.String?
  public var filterApplied: Swift.Bool {
    get
  }
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
public struct GLU {
  @discardableResult
  public static func compileShader(_ target: OpenGLES.GLenum, _ count: OpenGLES.GLsizei, _ sources: Swift.UnsafePointer<Swift.UnsafePointer<OpenGLES.GLchar>?>, _ shader: inout OpenGLES.GLuint) -> OpenGLES.GLint
  public static func linkProgram(_ program: OpenGLES.GLuint) -> OpenGLES.GLint
  public static func validateProgram(_ program: OpenGLES.GLuint) -> OpenGLES.GLint
  public static func getUniformLocation(_ program: OpenGLES.GLuint, _ uniformName: Swift.String) -> OpenGLES.GLint
  @discardableResult
  public static func createProgram(_ _vertSource: Swift.UnsafePointer<OpenGLES.GLchar>?, _ _fragSource: Swift.UnsafePointer<OpenGLES.GLchar>?, _ attribNames: [Swift.String], _ attribLocations: [OpenGLES.GLuint], _ uniformNames: [Swift.String], _ uniformLocations: inout [OpenGLES.GLint], _ program: inout OpenGLES.GLuint) -> OpenGLES.GLint
}
@objc public enum KanvasBrushType : Swift.Int {
  case pencil, marker, sharpie
  public func string() -> Swift.String
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
@objc public enum KanvasColorSelectionTool : Swift.Int {
  case swatch, gradient, eyedropper
  public func string() -> Swift.String
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
@objc public enum KanvasDrawingAction : Swift.Int {
  case tap, fill, stroke
  public func string() -> Swift.String
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
@objc public enum KanvasTextFont : Swift.Int {
  case regular, script
  public func string() -> Swift.String
  public static func from(font: UIKit.UIFont?) -> KanvasCamera.KanvasTextFont?
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
@objc public enum KanvasTextAlignment : Swift.Int {
  case left, center, right
  public func string() -> Swift.String
  public static func from(alignment: UIKit.NSTextAlignment?) -> KanvasCamera.KanvasTextAlignment?
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
@objc public enum KanvasDashboardOpenAction : Swift.Int {
  case tap, swipe
  public func string() -> Swift.String
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
@objc public enum KanvasDashboardDismissAction : Swift.Int {
  case tap, swipe
  public func string() -> Swift.String
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
@objc public enum KanvasMediaType : Swift.Int {
  case image, video, frames, livePhoto
  public func string() -> Swift.String
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
@objc public enum KanvasGIFPlaybackMode : Swift.Int {
  case loop, rebound, reverse
  public func string() -> Swift.String
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
@objc public protocol KanvasCameraAnalyticsProvider {
  @objc func logCameraOpen(mode: KanvasCamera.CameraMode)
  @objc func logDismiss()
  @objc func logCapturedMedia(type: KanvasCamera.CameraMode, cameraPosition: AVFoundation.AVCaptureDevice.Position, length: Foundation.TimeInterval, ghostFrameEnabled: Swift.Bool, filterType: KanvasCamera.FilterType)
  @objc func logFlipCamera()
  @objc func logDeleteSegment()
  @objc func logFlashToggled()
  @objc func logImagePreviewToggled(enabled: Swift.Bool)
  @objc func logUndoTapped()
  @objc func logNextTapped()
  @objc func logPreviewDismissed()
  @objc func logMovedClip()
  @objc func logPinchedZoom()
  @objc func logSwipedZoom()
  @objc func logConfirmedMedia(mode: KanvasCamera.CameraMode, clipsCount: Swift.Int, length: Foundation.TimeInterval)
  @objc func logOpenFiltersSelector()
  @objc func logFilterSelected(filterType: KanvasCamera.FilterType)
  @objc func logMediaPickerOpen()
  @objc func logMediaPickerDismiss()
  @objc func logMediaPickerPickedMedia(ofType mediaType: KanvasCamera.KanvasMediaType)
  @objc func logEditorOpen()
  @objc func logEditorBack()
  @objc func logEditorFiltersOpen()
  @objc func logEditorFilterSelected(filterType: KanvasCamera.FilterType)
  @objc func logEditorDrawingOpen()
  @objc func logEditorDrawingChangeStrokeSize(strokeSize: Swift.Float)
  @objc func logEditorDrawingChangeBrush(brushType: KanvasCamera.KanvasBrushType)
  @objc func logEditorDrawingChangeColor(selectionTool: KanvasCamera.KanvasColorSelectionTool)
  @objc func logEditorDrawStroke(brushType: KanvasCamera.KanvasBrushType, strokeSize: Swift.Float, drawType: KanvasCamera.KanvasDrawingAction)
  @objc func logEditorDrawingUndo()
  @objc func logEditorDrawingEraser(brushType: KanvasCamera.KanvasBrushType, strokeSize: Swift.Float, drawType: KanvasCamera.KanvasDrawingAction)
  @objc func logEditorDrawingConfirm()
  @objc func logEditorTextAdd()
  @objc func logEditorTextEdit()
  @objc func logEditorTextConfirm(isNew: Swift.Bool, font: KanvasCamera.KanvasTextFont, alignment: KanvasCamera.KanvasTextAlignment, highlighted: Swift.Bool)
  @objc func logEditorTextMove()
  @objc func logEditorTextRemove()
  @objc func logEditorTextChange(font: KanvasCamera.KanvasTextFont)
  @objc func logEditorTextChange(alignment: KanvasCamera.KanvasTextAlignment)
  @objc func logEditorTextChange(highlighted: Swift.Bool)
  @objc func logEditorTextChange(color: Swift.Bool)
  @objc func logEditorCreatedMedia(clipsCount: Swift.Int, length: Foundation.TimeInterval)
  @objc func logOpenFromDashboard(openAction: KanvasCamera.KanvasDashboardOpenAction)
  @objc func logDismissFromDashboard(dismissAction: KanvasCamera.KanvasDashboardDismissAction)
  @objc func logPostFromDashboard()
  @objc func logChangeBlogForPostFromDashboard()
  @objc func logSaveFromDashboard()
  @objc func logOpenComposeFromDashboard()
  @objc func logEditorTagTapped()
  @objc func logIconPresentedOnDashboard()
  @objc func logEditorMediaDrawerOpen()
  @objc func logEditorMediaDrawerClosed()
  @objc func logEditorMediaDrawerSelectStickers()
  @objc func logEditorStickerPackSelect(stickerPackId: Swift.String)
  @objc func logEditorStickerAdd(stickerId: Swift.String)
  @objc func logEditorStickerRemove(stickerId: Swift.String)
  @objc func logEditorStickerMove(stickerId: Swift.String)
  @objc func logEditorGIFButtonToggle(_ value: Swift.Bool)
  @objc func logEditorGIFOpen()
  @objc func logEditorGIFOpenTrim()
  @objc func logEditorGIFOpenSpeed()
  @objc func logEditorGIFRevert()
  @objc func logEditorGIFConfirm(duration: Foundation.TimeInterval, playbackMode: KanvasCamera.KanvasGIFPlaybackMode, speed: Swift.Float)
  @objc func logEditorGIFChange(playbackMode: KanvasCamera.KanvasGIFPlaybackMode)
  @objc func logEditorGIFChange(speed: Swift.Float)
  @objc func logEditorGIFChange(trimStart: Foundation.TimeInterval, trimEnd: Foundation.TimeInterval)
  @objc func logAdvancedOptionsOpen(page: Swift.String)
}
public struct KanvasCameraColors {
  public static var shared: KanvasCamera.KanvasCameraColors
  public init(drawingDefaultColor: UIKit.UIColor, colorPickerColors: [UIKit.UIColor], selectedPickerColor: UIKit.UIColor, timeSegmentColors: [UIKit.UIColor], backgroundColors: [UIKit.UIColor], strokeColor: UIKit.UIColor, sliderActiveColor: UIKit.UIColor, sliderOuterCircleColor: UIKit.UIColor, trimBackgroundColor: UIKit.UIColor, trashColor: UIKit.UIColor, tooltipBackgroundColor: UIKit.UIColor, closeButtonColor: UIKit.UIColor, filterColors: [KanvasCamera.FilterType : UIKit.UIColor])
}
public struct KanvasCameraFonts {
  public init(permissions: KanvasCamera.KanvasCameraFonts.CameraPermissions, drawer: KanvasCamera.KanvasCameraFonts.Drawer, editorFonts: [UIKit.UIFont], playbackCellFont: UIKit.UIFont, mediaClipsFont: UIKit.UIFont, modeButtonFont: UIKit.UIFont, speedLabelFont: UIKit.UIFont, timeIndicatorFont: UIKit.UIFont, colorSelectorTooltipFont: UIKit.UIFont, modeSelectorTooltipFont: UIKit.UIFont, postLabelFont: UIKit.UIFont, gifMakerRevertButtonFont: UIKit.UIFont, paddingAdjustment: ((UIKit.UIFont) -> KanvasCamera.KanvasCameraFonts.Padding?)?)
  public static var shared: KanvasCamera.KanvasCameraFonts
  public struct CameraPermissions {
    public init(titleFont: UIKit.UIFont, descriptionFont: UIKit.UIFont, buttonFont: UIKit.UIFont)
  }
  public struct Drawer {
    public init(textSelectedFont: UIKit.UIFont, textUnselectedFont: UIKit.UIFont)
  }
  public struct Padding {
    public init(topMargin: CoreGraphics.CGFloat, leftMargin: CoreGraphics.CGFloat, extraVerticalPadding: CoreGraphics.CGFloat, extraHorizontalPadding: CoreGraphics.CGFloat)
  }
}
public protocol KanvasQuickBlogSelectorCoordinating {
  func present(presentingView: UIKit.UIView, fromPoint: CoreGraphics.CGPoint)
  func dismiss()
  func touchDidMoveToPoint(_ location: CoreGraphics.CGPoint)
  func avatarView(frame: CoreGraphics.CGRect) -> UIKit.UIView?
}
public class LivePhotoLoader {
  public init(asset: Photos.PHAsset)
  public func pairedVideo(completion: @escaping (Foundation.URL?) -> Swift.Void)
  @objc deinit
}
public typealias MediaInfo = KanvasCamera.MediaInfoSimple
public struct MediaInfoSimple {
  public enum Source {
    case kanvas_camera
    case media_library
    public static func == (a: KanvasCamera.MediaInfoSimple.Source, b: KanvasCamera.MediaInfoSimple.Source) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public let source: KanvasCamera.MediaInfoSimple.Source
  public init(source: KanvasCamera.MediaInfoSimple.Source)
}
extension MediaInfoSimple : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension MediaInfoSimple.Source : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
  public func stringValue() -> Swift.String
}
extension MediaInfoSimple {
  public init?(fromImage url: Foundation.URL)
  public init?(fromImageData data: Foundation.Data)
  public func write(toImage url: Foundation.URL)
}
extension MediaInfoSimple {
  public init?(fromVideoURL url: Foundation.URL)
  public func createAVMetadataItems() -> [AVFoundation.AVMetadataItem]
}
extension UInt8 : Swift.ExpressibleByBooleanLiteral {
  public var boolValue: Swift.Bool {
    get
  }
  public init(booleanLiteral value: Swift.BooleanLiteralType)
  public typealias BooleanLiteralType = Swift.BooleanLiteralType
}
extension Int32 : Swift.ExpressibleByBooleanLiteral {
  public init(booleanLiteral value: Swift.BooleanLiteralType)
  public typealias BooleanLiteralType = Swift.BooleanLiteralType
}
extension Int {
  public var g: CoreGraphics.CGFloat {
    get
  }
  public var d: Swift.Double {
    get
  }
  public var f: Swift.Float {
    get
  }
  public var b: Swift.Int8 {
    get
  }
  public var ub: Swift.UInt8 {
    get
  }
  public var s: Swift.Int16 {
    get
  }
  public var us: Swift.UInt16 {
    get
  }
  public var i: Swift.Int32 {
    get
  }
  public var ui: Swift.UInt32 {
    get
  }
  public var ul: Swift.UInt {
    get
  }
  public var ll: Swift.Int64 {
    get
  }
  public var ull: Swift.UInt64 {
    get
  }
}
extension UInt {
  public var g: CoreGraphics.CGFloat {
    get
  }
  public var d: Swift.Double {
    get
  }
  public var f: Swift.Float {
    get
  }
  public var b: Swift.Int8 {
    get
  }
  public var ub: Swift.UInt8 {
    get
  }
  public var s: Swift.Int16 {
    get
  }
  public var us: Swift.UInt16 {
    get
  }
  public var i: Swift.Int32 {
    get
  }
  public var ui: Swift.UInt32 {
    get
  }
  public var l: Swift.Int {
    get
  }
  public var ll: Swift.Int64 {
    get
  }
  public var ull: Swift.UInt64 {
    get
  }
}
extension Int32 {
  public var g: CoreGraphics.CGFloat {
    get
  }
  public var d: Swift.Double {
    get
  }
  public var f: Swift.Float {
    get
  }
  public var b: Swift.Int8 {
    get
  }
  public var ub: Swift.UInt8 {
    get
  }
  public var s: Swift.Int16 {
    get
  }
  public var us: Swift.UInt16 {
    get
  }
  public var ui: Swift.UInt32 {
    get
  }
  public var l: Swift.Int {
    get
  }
  public var ul: Swift.UInt {
    get
  }
  public var ll: Swift.Int64 {
    get
  }
  public var ull: Swift.UInt64 {
    get
  }
}
extension UInt32 {
  public var g: CoreGraphics.CGFloat {
    get
  }
  public var d: Swift.Double {
    get
  }
  public var f: Swift.Float {
    get
  }
  public var b: Swift.Int8 {
    get
  }
  public var ub: Swift.UInt8 {
    get
  }
  public var s: Swift.Int16 {
    get
  }
  public var us: Swift.UInt16 {
    get
  }
  public var i: Swift.Int32 {
    get
  }
  public var l: Swift.Int {
    get
  }
  public var ul: Swift.UInt {
    get
  }
  public var ll: Swift.Int64 {
    get
  }
  public var ull: Swift.UInt64 {
    get
  }
}
extension UInt64 {
  public var g: CoreGraphics.CGFloat {
    get
  }
  public var d: Swift.Double {
    get
  }
  public var f: Swift.Float {
    get
  }
  public var b: Swift.Int8 {
    get
  }
  public var ub: Swift.UInt8 {
    get
  }
  public var s: Swift.Int16 {
    get
  }
  public var us: Swift.UInt16 {
    get
  }
  public var i: Swift.Int32 {
    get
  }
  public var ui: Swift.UInt32 {
    get
  }
  public var l: Swift.Int {
    get
  }
  public var ul: Swift.UInt {
    get
  }
  public var ll: Swift.Int64 {
    get
  }
}
extension Float {
  public var g: CoreGraphics.CGFloat {
    get
  }
  public var d: Swift.Double {
    get
  }
}
extension Double {
  public var g: CoreGraphics.CGFloat {
    get
  }
  public var f: Swift.Float {
    get
  }
}
extension CGFloat {
  public var d: Swift.Double {
    get
  }
  public var f: Swift.Float {
    get
  }
  public var i: Swift.Int32 {
    get
  }
}
public struct Sticker {
  public init(id: Swift.String, imageUrl: Swift.String)
}
public protocol KanvasCancelable {
  func cancel()
}
public protocol KanvasStickerLoader {
  func loadSticker(at imageURL: Foundation.URL, imageView: UIKit.UIImageView?, completion: @escaping (UIKit.UIImage?, Swift.Error?) -> Swift.Void) -> KanvasCamera.KanvasCancelable
}
public protocol StickerProviderDelegate : AnyObject {
  func didLoadStickerTypes(_ stickerTypes: [KanvasCamera.StickerType])
}
public protocol StickerProvider {
  func getStickerTypes()
  func setDelegate(delegate: KanvasCamera.StickerProviderDelegate)
  func loader() -> KanvasCamera.KanvasStickerLoader?
}
public struct StickerType : Swift.Equatable {
  public init(id: Swift.String, imageUrl: Swift.String, stickers: [KanvasCamera.Sticker])
  public static func == (lhs: KanvasCamera.StickerType, rhs: KanvasCamera.StickerType) -> Swift.Bool
}
public protocol Identifiable {
  static var identifier: Swift.String { get }
}
extension Identifiable {
  public static var identifier: Swift.String {
    get
  }
}
extension UITableViewCell : KanvasCamera.Identifiable {
}
extension UICollectionReusableView : KanvasCamera.Identifiable {
}
extension UITableViewHeaderFooterView : KanvasCamera.Identifiable {
}
extension UICollectionView {
  public func register<T>(cell cellType: T.Type) where T : UIKit.UICollectionViewCell
  public func register<T>(header headerType: T.Type) where T : UIKit.UICollectionReusableView
  public func register<T>(footer footerType: T.Type) where T : UIKit.UICollectionReusableView
  public func dequeue<T>(cell cellType: T.Type, for indexPath: Foundation.IndexPath) -> T? where T : UIKit.UICollectionViewCell
  public func dequeue<T>(header headerType: T.Type, for indexPath: Foundation.IndexPath) -> T? where T : UIKit.UICollectionReusableView
  public func dequeue<T>(footer footerType: T.Type, for indexPath: Foundation.IndexPath) -> T? where T : UIKit.UICollectionReusableView
  public func dequeue<T>(view viewType: T.Type, ofKind kind: Swift.String, for indexPath: Foundation.IndexPath) -> T? where T : UIKit.UICollectionReusableView
}
extension UIColor {
  convenience public init(hex: Swift.String, alpha: CoreGraphics.CGFloat = 1.0)
  convenience public init(hex: Swift.Int, alpha: CoreGraphics.CGFloat = 1.0)
  convenience public init(hex: Swift.UInt32, alpha: CoreGraphics.CGFloat = 1.0)
  @objc(colorWithHex:) public static func color(hex: Swift.UInt) -> UIKit.UIColor
}
extension UIColor {
  public func matchingColor() -> UIKit.UIColor
  public func calculateRGBComponents() -> (red: CoreGraphics.CGFloat, green: CoreGraphics.CGFloat, blue: CoreGraphics.CGFloat, alpha: CoreGraphics.CGFloat)
  public func calculateRGBComponentIntegers() -> (red: Swift.Int, green: Swift.Int, blue: Swift.Int, alpha: Swift.Int)
  public func brighterThan(_ brightnessValue: Swift.Double) -> Swift.Bool
}
extension UIImage {
  public func flipLeftMirrored() -> UIKit.UIImage?
}
extension UIImage {
  convenience public init?(pixelBuffer: CoreVideo.CVPixelBuffer)
}
extension KanvasCamera.KanvasExportAction : Swift.Equatable {}
extension KanvasCamera.KanvasExportAction : Swift.Hashable {}
extension KanvasCamera.ImagePreviewMode : Swift.Equatable {}
extension KanvasCamera.ImagePreviewMode : Swift.Hashable {}
extension KanvasCamera.CameraMode : Swift.Equatable {}
extension KanvasCamera.CameraMode : Swift.Hashable {}
extension KanvasCamera.CameraMode : Swift.RawRepresentable {}
extension KanvasCamera.CameraMode.Group : Swift.Equatable {}
extension KanvasCamera.CameraMode.Group : Swift.Hashable {}
extension KanvasCamera.CameraMode.Group : Swift.RawRepresentable {}
extension KanvasCamera.CameraMode.Quantity : Swift.Equatable {}
extension KanvasCamera.CameraMode.Quantity : Swift.Hashable {}
extension KanvasCamera.CameraMode.Quantity : Swift.RawRepresentable {}
extension KanvasCamera.EasyTipView.ArrowPosition : Swift.Equatable {}
extension KanvasCamera.EasyTipView.ArrowPosition : Swift.Hashable {}
extension KanvasCamera.FilterType : Swift.Equatable {}
extension KanvasCamera.FilterType : Swift.Hashable {}
extension KanvasCamera.FilterType : Swift.RawRepresentable {}
extension KanvasCamera.KanvasBrushType : Swift.Equatable {}
extension KanvasCamera.KanvasBrushType : Swift.Hashable {}
extension KanvasCamera.KanvasBrushType : Swift.RawRepresentable {}
extension KanvasCamera.KanvasColorSelectionTool : Swift.Equatable {}
extension KanvasCamera.KanvasColorSelectionTool : Swift.Hashable {}
extension KanvasCamera.KanvasColorSelectionTool : Swift.RawRepresentable {}
extension KanvasCamera.KanvasDrawingAction : Swift.Equatable {}
extension KanvasCamera.KanvasDrawingAction : Swift.Hashable {}
extension KanvasCamera.KanvasDrawingAction : Swift.RawRepresentable {}
extension KanvasCamera.KanvasTextFont : Swift.Equatable {}
extension KanvasCamera.KanvasTextFont : Swift.Hashable {}
extension KanvasCamera.KanvasTextFont : Swift.RawRepresentable {}
extension KanvasCamera.KanvasTextAlignment : Swift.Equatable {}
extension KanvasCamera.KanvasTextAlignment : Swift.Hashable {}
extension KanvasCamera.KanvasTextAlignment : Swift.RawRepresentable {}
extension KanvasCamera.KanvasDashboardOpenAction : Swift.Equatable {}
extension KanvasCamera.KanvasDashboardOpenAction : Swift.Hashable {}
extension KanvasCamera.KanvasDashboardOpenAction : Swift.RawRepresentable {}
extension KanvasCamera.KanvasDashboardDismissAction : Swift.Equatable {}
extension KanvasCamera.KanvasDashboardDismissAction : Swift.Hashable {}
extension KanvasCamera.KanvasDashboardDismissAction : Swift.RawRepresentable {}
extension KanvasCamera.KanvasMediaType : Swift.Equatable {}
extension KanvasCamera.KanvasMediaType : Swift.Hashable {}
extension KanvasCamera.KanvasMediaType : Swift.RawRepresentable {}
extension KanvasCamera.KanvasGIFPlaybackMode : Swift.Equatable {}
extension KanvasCamera.KanvasGIFPlaybackMode : Swift.Hashable {}
extension KanvasCamera.KanvasGIFPlaybackMode : Swift.RawRepresentable {}
extension KanvasCamera.MediaInfoSimple.Source : Swift.Equatable {}
extension KanvasCamera.MediaInfoSimple.Source : Swift.Hashable {}
